
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "content/examples/09-flow/plot_inv_flow_richards_1D.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_content_examples_09-flow_plot_inv_flow_richards_1D.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_content_examples_09-flow_plot_inv_flow_richards_1D.py:


FLOW: Richards: 1D: Inversion
=============================

The example shows an inversion of Richards equation in 1D with a
heterogeneous hydraulic conductivity function.

The haverkamp model is used with the same parameters as Celia1990_
the boundary and initial conditions are also the same. The simulation
domain is 40cm deep and is run for an hour with an exponentially
increasing time step that has a maximum of one minute. The general
setup of the experiment is an infiltration front that advances
downward through the model over time.

The model chosen is the saturated hydraulic conductivity inside
the hydraulic conductivity function (using haverkamp). The initial
model is chosen to be the background (1e-3 cm/s). The saturation data
has 2% random Gaussian noise added.

The figure shows the recovered saturated hydraulic conductivity
next to the true model. The other two figures show the saturation
field for the entire simulation for the true and recovered models.

Rowan Cockett - 21/12/2016

.. _Celia1990: http://www.webpages.uidaho.edu/ch/papers/Celia.pdf

.. GENERATED FROM PYTHON SOURCE LINES 28-155



.. image-sg:: /content/examples/09-flow/images/sphx_glr_plot_inv_flow_richards_1D_001.png
   :alt: True saturation over time, Recovered saturation over time
   :srcset: /content/examples/09-flow/images/sphx_glr_plot_inv_flow_richards_1D_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/vsts/work/1/s/simpeg/flow/richards/simulation.py:40: FutureWarning:

    verbose.debug has been deprecated, please use verbose. It will be removed in version 0.19.0 of SimPEG.

    /home/vsts/work/1/s/simpeg/flow/richards/simulation.py:321: UserWarning:

    cell_gradient_BC is deprecated and is not longer used. See cell_gradient


    Running inversion with SimPEG v0.22.1
    simpeg.InvProblem will set Regularization.reference_model to m0.
    simpeg.InvProblem will set Regularization.reference_model to m0.
    simpeg.InvProblem will set Regularization.reference_model to m0.

                            simpeg.InvProblem is setting bfgsH0 to the inverse of the eval2Deriv.
                            ***Done using same Solver, and solver_opts as the SimulationNDCellCentered problem***
                        
    /home/vsts/work/1/s/simpeg/flow/richards/simulation.py:271: UserWarning:

    cell_gradient_BC is deprecated and is not longer used. See cell_gradient

    /usr/share/miniconda/envs/simpeg-test/lib/python3.8/site-packages/pymatsolver/direct.py:23: PardisoTypeConversionWarning:

    Converting csc_matrix matrix to CSR format.

    /usr/share/miniconda/envs/simpeg-test/lib/python3.8/site-packages/pymatsolver/direct.py:73: PardisoTypeConversionWarning:

    Converting csc_matrix matrix to CSR format.

    model has any nan: 0
    ============================ Inexact Gauss Newton ============================
      #     beta     phi_d     phi_m       f      |proj(x-g)-x|  LS    Comment   
    -----------------------------------------------------------------------------
    x0 has any nan: 0
       0  2.63e+05  1.95e+05  0.00e+00  1.95e+05    2.90e+04      0              
       1  2.63e+05  1.85e+05  1.42e-02  1.89e+05    7.35e+03      0              
       2  2.63e+05  1.83e+05  2.25e-02  1.89e+05    1.83e+03      0   Skip BFGS  
       3  6.56e+04  1.83e+05  2.30e-02  1.84e+05    2.26e+04      2   Skip BFGS  
       4  6.56e+04  1.66e+05  1.29e-01  1.74e+05    1.27e+04      0              
       5  6.56e+04  1.55e+05  2.29e-01  1.70e+05    9.77e+03      0   Skip BFGS  
       6  1.64e+04  1.48e+05  3.17e-01  1.53e+05    2.51e+04      0   Skip BFGS  
       7  1.64e+04  1.22e+05  7.18e-01  1.34e+05    2.29e+04      0              
       8  1.64e+04  9.97e+04  1.16e+00  1.19e+05    1.97e+04      0   Skip BFGS  
       9  4.10e+03  8.11e+04  1.59e+00  8.77e+04    3.01e+04      0   Skip BFGS  
    NewtonRoot stopped by maxIters (30). norm: 1.1322e-04
      10  4.10e+03  5.74e+04  2.39e+00  6.72e+04    3.09e+04      0              
    NewtonRoot stopped by maxIters (30). norm: 4.5319e-04
      11  4.10e+03  3.44e+04  3.04e+00  4.69e+04    2.80e+04      0              
      12  1.03e+03  1.61e+04  3.69e+00  1.99e+04    3.12e+04      0              
      13  1.03e+03  5.78e+03  4.67e+00  1.06e+04    2.29e+04      0              
      14  1.03e+03  2.15e+03  5.14e+00  7.42e+03    9.16e+03      0              
    NewtonRoot stopped by maxIters (30). norm: 3.0865e-04
      15  2.56e+02  1.84e+03  5.05e+00  3.14e+03    7.92e+03      0              
      16  2.56e+02  1.20e+03  6.26e+00  2.81e+03    7.46e+03      0              
    NewtonRoot stopped by maxIters (30). norm: 2.7113e-04
      17  2.56e+02  1.13e+03  6.22e+00  2.72e+03    7.14e+03      1              
      18  6.41e+01  9.29e+02  6.46e+00  1.34e+03    3.49e+03      0              
      19  6.41e+01  7.79e+02  7.94e+00  1.29e+03    7.62e+03      0              
      20  6.41e+01  5.60e+02  7.64e+00  1.05e+03    2.96e+03      0              
    ------------------------- STOP! -------------------------
    1 : |fc-fOld| = 2.3811e+02 <= tolF*(1+|f0|) = 1.9499e+04
    1 : |xc-x_last| = 5.3613e-01 <= tolX*(1+|x0|) = 4.4688e+00
    0 : |proj(x-g)-x|    = 2.9594e+03 <= tolG          = 1.0000e-01
    0 : |proj(x-g)-x|    = 2.9594e+03 <= 1e3*eps       = 1.0000e-02
    1 : maxIter   =      20    <= iter          =     20
    ------------------------- DONE! -------------------------






|

.. code-block:: Python


    import matplotlib
    import matplotlib.pyplot as plt
    import numpy as np

    import discretize
    from simpeg import maps
    from simpeg import regularization
    from simpeg import data_misfit
    from simpeg import optimization
    from simpeg import inverse_problem
    from simpeg import directives
    from simpeg import inversion

    from simpeg.flow import richards


    def run(plotIt=True):
        M = discretize.TensorMesh([np.ones(40)], x0="N")
        M.set_cell_gradient_BC("dirichlet")
        # We will use the haverkamp empirical model with parameters from Celia1990
        k_fun, theta_fun = richards.empirical.haverkamp(
            M,
            A=1.1750e06,
            gamma=4.74,
            alpha=1.6110e06,
            theta_s=0.287,
            theta_r=0.075,
            beta=3.96,
        )

        # Here we are making saturated hydraulic conductivity
        # an exponential mapping to the model (defined below)
        k_fun.KsMap = maps.ExpMap(nP=M.nC)

        # Setup the boundary and initial conditions
        bc = np.array([-61.5, -20.7])
        h = np.zeros(M.nC) + bc[0]
        prob = richards.SimulationNDCellCentered(
            M,
            hydraulic_conductivity=k_fun,
            water_retention=theta_fun,
            boundary_conditions=bc,
            initial_conditions=h,
            do_newton=False,
            method="mixed",
            debug=False,
        )
        prob.time_steps = [(5, 25, 1.1), (60, 40)]

        # Create the survey
        locs = -np.arange(2, 38, 4.0).reshape(-1, 1)
        times = np.arange(30, prob.time_mesh.cell_centers_x[-1], 60)
        rxSat = richards.receivers.Saturation(locs, times)
        survey = richards.Survey([rxSat])
        prob.survey = survey

        # Create a simple model for Ks
        Ks = 1e-3
        mtrue = np.ones(M.nC) * np.log(Ks)
        mtrue[15:20] = np.log(5e-2)
        mtrue[20:35] = np.log(3e-3)
        mtrue[35:40] = np.log(1e-2)
        m0 = np.ones(M.nC) * np.log(Ks)

        # Create some synthetic data and fields
        relative = 0.02  # The standard deviation for the noise
        Hs = prob.fields(mtrue)
        data = prob.make_synthetic_data(
            mtrue, relative_error=relative, f=Hs, add_noise=True
        )

        # Setup a pretty standard inversion
        reg = regularization.WeightedLeastSquares(M, alpha_s=1e-1)
        dmis = data_misfit.L2DataMisfit(simulation=prob, data=data)
        opt = optimization.InexactGaussNewton(maxIter=20, maxIterCG=10)
        invProb = inverse_problem.BaseInvProblem(dmis, reg, opt)
        beta = directives.BetaSchedule(coolingFactor=4)
        betaest = directives.BetaEstimate_ByEig(beta0_ratio=1e2)
        target = directives.TargetMisfit()
        dir_list = [beta, betaest, target]
        inv = inversion.BaseInversion(invProb, directiveList=dir_list)

        mopt = inv.run(m0)

        Hs_opt = prob.fields(mopt)

        if plotIt:
            plt.figure(figsize=(14, 9))

            ax = plt.subplot(121)
            plt.semilogx(np.exp(np.c_[mopt, mtrue]), M.gridCC)
            plt.xlabel("Saturated Hydraulic Conductivity, $K_s$")
            plt.ylabel("Depth, cm")
            plt.semilogx([10**-3.9] * len(locs), locs, "ro")
            plt.legend(("$m_{rec}$", "$m_{true}$", "Data locations"), loc=4)

            ax = plt.subplot(222)
            mesh2d = discretize.TensorMesh([prob.time_mesh.h[0] / 60, prob.mesh.h[0]], "0N")
            sats = [theta_fun(_) for _ in Hs]
            clr = mesh2d.plot_image(np.c_[sats][1:, :], ax=ax)
            cmap0 = matplotlib.cm.RdYlBu_r
            clr[0].set_cmap(cmap0)
            c = plt.colorbar(clr[0])
            c.set_label("Saturation $\\theta$")
            plt.xlabel("Time, minutes")
            plt.ylabel("Depth, cm")
            plt.title("True saturation over time")

            ax = plt.subplot(224)
            mesh2d = discretize.TensorMesh([prob.time_mesh.h[0] / 60, prob.mesh.h[0]], "0N")
            sats = [theta_fun(_) for _ in Hs_opt]
            clr = mesh2d.plot_image(np.c_[sats][1:, :], ax=ax)
            cmap0 = matplotlib.cm.RdYlBu_r
            clr[0].set_cmap(cmap0)
            c = plt.colorbar(clr[0])
            c.set_label("Saturation $\\theta$")
            plt.xlabel("Time, minutes")
            plt.ylabel("Depth, cm")
            plt.title("Recovered saturation over time")

            plt.tight_layout()


    if __name__ == "__main__":
        run()
        plt.show()


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (3 minutes 45.035 seconds)

**Estimated memory usage:**  9 MB


.. _sphx_glr_download_content_examples_09-flow_plot_inv_flow_richards_1D.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_inv_flow_richards_1D.ipynb <plot_inv_flow_richards_1D.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_inv_flow_richards_1D.py <plot_inv_flow_richards_1D.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
