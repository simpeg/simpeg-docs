
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "content/examples/01-maps/plot_sumMap.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_content_examples_01-maps_plot_sumMap.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_content_examples_01-maps_plot_sumMap.py:


Maps: ComboMaps
===============

Invert synthetic magnetic data with variable background values
and a single block anomaly buried at depth. We will use the Sum Map
to invert for both the background values and an heterogeneous susceptibiilty
model.

.. code-block:: python
    :linenos:

.. GENERATED FROM PYTHON SOURCE LINES 15-207



.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /content/examples/01-maps/images/sphx_glr_plot_sumMap_001.png
         :alt: plot sumMap
         :srcset: /content/examples/01-maps/images/sphx_glr_plot_sumMap_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /content/examples/01-maps/images/sphx_glr_plot_sumMap_002.png
         :alt: plot sumMap
         :srcset: /content/examples/01-maps/images/sphx_glr_plot_sumMap_002.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Running inversion with SimPEG v0.22.0

                        simpeg.InvProblem is setting bfgsH0 to the inverse of the eval2Deriv.
                        ***Done using the default solver Pardiso and no solver_opts.***
                    
    model has any nan: 0
    =============================== Projected GNCG ===============================
      #     beta     phi_d     phi_m       f      |proj(x-g)-x|  LS    Comment   
    -----------------------------------------------------------------------------
    x0 has any nan: 0
       0  5.52e+05  9.11e+06  4.27e-04  9.11e+06    6.29e+01      0              
       1  2.76e+05  1.29e+05  7.89e-02  1.51e+05    3.50e+01      0              
       2  1.38e+05  4.44e+04  2.39e-01  7.74e+04    4.96e+01      0              
       3  6.90e+04  1.90e+04  3.68e-01  4.44e+04    5.54e+01      0   Skip BFGS  
       4  3.45e+04  6.16e+03  4.80e-01  2.27e+04    4.85e+01      0   Skip BFGS  
       5  1.72e+04  4.58e+03  5.13e-01  1.34e+04    3.57e+01      1   Skip BFGS  
       6  8.62e+03  9.70e+02  6.03e-01  6.17e+03    4.80e+01      0              
       7  4.31e+03  9.65e+02  6.03e-01  3.57e+03    5.04e+01      5   Skip BFGS  
       8  2.16e+03  4.98e+02  6.48e-01  1.90e+03    4.58e+01      0              
       9  1.08e+03  4.96e+02  6.49e-01  1.20e+03    3.43e+01      4   Skip BFGS  
      10  5.39e+02  4.39e+02  6.72e-01  8.00e+02    5.48e+01      0              
      11  2.69e+02  4.39e+02  6.72e-01  6.20e+02    5.48e+01     13   Skip BFGS  
      12  1.35e+02  4.38e+02  6.72e-01  5.29e+02    3.50e+01      5              
      13  6.73e+01  4.32e+02  6.98e-01  4.79e+02    3.90e+01      0   Skip BFGS  
      14  3.37e+01  4.24e+02  6.96e-01  4.48e+02    6.27e+01      2              
      15  1.68e+01  4.24e+02  6.96e-01  4.36e+02    6.27e+01     11   Skip BFGS  
      16  8.42e+00  4.21e+02  6.96e-01  4.27e+02    5.13e+01      2   Skip BFGS  
      17  4.21e+00  4.20e+02  7.03e-01  4.23e+02    3.63e+01      2   Skip BFGS  
      18  2.10e+00  4.20e+02  7.03e-01  4.22e+02    3.63e+01     11   Skip BFGS  
      19  1.05e+00  4.20e+02  7.03e-01  4.21e+02    5.72e+01      4              
      20  5.26e-01  4.16e+02  7.59e-01  4.17e+02    6.02e+01      0   Skip BFGS  
      21  2.63e-01  4.01e+02  7.64e-01  4.01e+02    3.83e+01      0              
      22  1.32e-01  4.01e+02  7.64e-01  4.01e+02    3.81e+01      4   Skip BFGS  
    Reached starting chifact with l2-norm regularization: Start IRLS steps...
    irls_threshold 0.010168649175490006
    irls_threshold 0.012880254136899411
      23  6.58e-02  3.99e+02  1.08e+00  3.99e+02    4.78e+01      3   Skip BFGS  
      24  6.58e-02  3.99e+02  1.17e+00  3.99e+02    4.47e+01      3              
      25  6.58e-02  3.99e+02  1.25e+00  3.99e+02    3.76e+01      4   Skip BFGS  
      26  6.58e-02  3.98e+02  1.31e+00  3.98e+02    5.96e+01      4              
      27  6.58e-02  3.98e+02  1.33e+00  3.98e+02    5.96e+01     18   Skip BFGS  
      28  6.58e-02  3.98e+02  1.34e+00  3.98e+02    5.96e+01     12   Skip BFGS  
      29  6.58e-02  3.98e+02  1.33e+00  3.98e+02    6.11e+01      4              
      30  6.58e-02  3.97e+02  1.30e+00  3.97e+02    5.16e+01      5              
      31  6.58e-02  3.97e+02  1.25e+00  3.97e+02    4.92e+01      8   Skip BFGS  
      32  6.58e-02  3.97e+02  1.18e+00  3.97e+02    3.64e+01      5   Skip BFGS  
      33  6.58e-02  3.95e+02  1.15e+00  3.95e+02    3.71e+01      3   Skip BFGS  
      34  6.58e-02  3.94e+02  1.06e+00  3.94e+02    4.98e+01      4              
      35  6.58e-02  3.94e+02  9.68e-01  3.94e+02    5.33e+01      6   Skip BFGS  
      36  6.58e-02  3.94e+02  8.78e-01  3.94e+02    3.58e+01      6              
      37  6.58e-02  3.94e+02  7.86e-01  3.94e+02    3.54e+01      9   Skip BFGS  
      38  6.58e-02  3.94e+02  7.00e-01  3.94e+02    5.30e+01      6              
      39  6.58e-02  3.93e+02  6.35e-01  3.93e+02    6.06e+01      3   Skip BFGS  
      40  6.58e-02  3.92e+02  5.63e-01  3.92e+02    3.65e+01      3              
      41  6.58e-02  3.92e+02  4.92e-01  3.92e+02    3.65e+01     17   Skip BFGS  
      42  6.58e-02  3.92e+02  4.29e-01  3.92e+02    4.57e+01      4              
    Reach maximum number of IRLS cycles: 20
    ------------------------- STOP! -------------------------
    1 : |fc-fOld| = 0.0000e+00 <= tolF*(1+|f0|) = 9.1089e+05
    1 : |xc-x_last| = 1.0305e-02 <= tolX*(1+|x0|) = 1.0075e-01
    0 : |proj(x-g)-x|    = 4.5709e+01 <= tolG          = 1.0000e-03
    0 : |proj(x-g)-x|    = 4.5709e+01 <= 1e3*eps       = 1.0000e-03
    0 : maxIter   =     100    <= iter          =     43
    ------------------------- DONE! -------------------------






|

.. code-block:: Python


    from discretize import TensorMesh
    from discretize.utils import active_from_xyz
    from simpeg import (
        utils,
        maps,
        regularization,
        data_misfit,
        optimization,
        inverse_problem,
        directives,
        inversion,
    )
    from simpeg.potential_fields import magnetics
    import numpy as np
    import matplotlib.pyplot as plt


    def run(plotIt=True):
        h0_amplitude, h0_inclination, h0_declination = (50000.0, 90.0, 0.0)

        # Create a mesh
        dx = 5.0

        hxind = [(dx, 5, -1.3), (dx, 10), (dx, 5, 1.3)]
        hyind = [(dx, 5, -1.3), (dx, 10), (dx, 5, 1.3)]
        hzind = [(dx, 5, -1.3), (dx, 10)]

        mesh = TensorMesh([hxind, hyind, hzind], "CCC")

        # Lets create a simple Gaussian topo and set the active cells
        [xx, yy] = np.meshgrid(mesh.nodes_x, mesh.nodes_y)
        zz = -np.exp((xx**2 + yy**2) / 75**2) + mesh.nodes_z[-1]

        # We would usually load a topofile
        topo = np.c_[utils.mkvc(xx), utils.mkvc(yy), utils.mkvc(zz)]

        # Go from topo to array of indices of active cells
        actv = active_from_xyz(mesh, topo, "N")
        nC = int(actv.sum())
        # Create and array of observation points
        xr = np.linspace(-20.0, 20.0, 20)
        yr = np.linspace(-20.0, 20.0, 20)
        X, Y = np.meshgrid(xr, yr)

        # Move the observation points 5m above the topo
        Z = -np.exp((X**2 + Y**2) / 75**2) + mesh.nodes_z[-1] + 5.0

        # Create a MAGsurvey
        rxLoc = np.c_[utils.mkvc(X.T), utils.mkvc(Y.T), utils.mkvc(Z.T)]
        rxLoc = magnetics.Point(rxLoc)
        srcField = magnetics.UniformBackgroundField(
            receiver_list=[rxLoc],
            amplitude=h0_amplitude,
            inclination=h0_inclination,
            declination=h0_declination,
        )
        survey = magnetics.Survey(srcField)

        # We can now create a susceptibility model and generate data
        model = np.zeros(mesh.nC)

        # Change values in half the domain
        model[mesh.gridCC[:, 0] < 0] = 0.01

        # Add a block in half-space
        model = utils.model_builder.add_block(
            mesh.gridCC, model, np.r_[-10, -10, 20], np.r_[10, 10, 40], 0.05
        )

        model = utils.mkvc(model)
        model = model[actv]

        # Create active map to go from reduce set to full
        actvMap = maps.InjectActiveCells(mesh, actv, np.nan)

        # Create reduced identity map
        idenMap = maps.IdentityMap(nP=nC)

        # Create the forward model operator
        prob = magnetics.Simulation3DIntegral(
            mesh,
            survey=survey,
            chiMap=idenMap,
            ind_active=actv,
            store_sensitivities="forward_only",
        )

        # Compute linear forward operator and compute some data
        data = prob.make_synthetic_data(
            model, relative_error=0.0, noise_floor=1, add_noise=True
        )

        # Create a homogenous maps for the two domains
        domains = [mesh.gridCC[actv, 0] < 0, mesh.gridCC[actv, 0] >= 0]
        homogMap = maps.SurjectUnits(domains)

        # Create a wire map for a second model space, voxel based
        wires = maps.Wires(("homo", len(domains)), ("hetero", nC))

        # Create Sum map
        sumMap = maps.SumMap([homogMap * wires.homo, wires.hetero])

        # Create the forward model operator
        prob = magnetics.Simulation3DIntegral(
            mesh, survey=survey, chiMap=sumMap, ind_active=actv, store_sensitivities="ram"
        )

        # Make sensitivity weighting
        # Take the cell number out of the scaling.
        # Want to keep high sens for large volumes
        wr = (
            prob.getJtJdiag(np.ones(sumMap.shape[1]))
            / np.r_[homogMap.P.T * mesh.cell_volumes[actv], mesh.cell_volumes[actv]] ** 2.0
        )
        # Scale the model spaces independently
        wr[wires.homo.index] /= np.max((wires.homo * wr)) * utils.mkvc(
            homogMap.P.sum(axis=0).flatten()
        )
        wr[wires.hetero.index] /= np.max(wires.hetero * wr)
        wr = wr**0.5

        ## Create a regularization
        # For the homogeneous model
        regMesh = TensorMesh([len(domains)])

        reg_m1 = regularization.Sparse(regMesh, mapping=wires.homo)
        reg_m1.set_weights(weights=wires.homo * wr)

        reg_m1.norms = [0, 2]
        reg_m1.reference_model = np.zeros(sumMap.shape[1])

        # Regularization for the voxel model
        reg_m2 = regularization.Sparse(
            mesh, active_cells=actv, mapping=wires.hetero, gradient_type="components"
        )
        reg_m2.set_weights(weights=wires.hetero * wr)

        reg_m2.norms = [0, 0, 0, 0]
        reg_m2.reference_model = np.zeros(sumMap.shape[1])

        reg = reg_m1 + reg_m2

        # Data misfit function
        dmis = data_misfit.L2DataMisfit(simulation=prob, data=data)

        # Add directives to the inversion
        opt = optimization.ProjectedGNCG(
            maxIter=100,
            lower=0.0,
            upper=1.0,
            maxIterLS=20,
            maxIterCG=10,
            tolCG=1e-3,
            tolG=1e-3,
            eps=1e-6,
        )
        invProb = inverse_problem.BaseInvProblem(dmis, reg, opt)
        betaest = directives.BetaEstimate_ByEig(beta0_ratio=1e-2)

        # Here is where the norms are applied
        # Use pick a threshold parameter empirically based on the distribution of
        #  model parameters
        IRLS = directives.Update_IRLS(f_min_change=1e-3, minGNiter=1)
        update_Jacobi = directives.UpdatePreconditioner()
        inv = inversion.BaseInversion(invProb, directiveList=[IRLS, betaest, update_Jacobi])

        # Run the inversion
        m0 = np.ones(sumMap.shape[1]) * 1e-4  # Starting model
        prob.model = m0
        mrecSum = inv.run(m0)
        if plotIt:
            mesh.plot_3d_slicer(
                actvMap * model,
                aspect="equal",
                zslice=30,
                pcolor_opts={"cmap": "inferno_r"},
                transparent="slider",
            )

            mesh.plot_3d_slicer(
                actvMap * sumMap * mrecSum,
                aspect="equal",
                zslice=30,
                pcolor_opts={"cmap": "inferno_r"},
                transparent="slider",
            )


    if __name__ == "__main__":
        run()
        plt.show()


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 50.296 seconds)

**Estimated memory usage:**  44 MB


.. _sphx_glr_download_content_examples_01-maps_plot_sumMap.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_sumMap.ipynb <plot_sumMap.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_sumMap.py <plot_sumMap.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
