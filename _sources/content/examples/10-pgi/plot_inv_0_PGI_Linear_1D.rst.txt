
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "content/examples/10-pgi/plot_inv_0_PGI_Linear_1D.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_content_examples_10-pgi_plot_inv_0_PGI_Linear_1D.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_content_examples_10-pgi_plot_inv_0_PGI_Linear_1D.py:


Petrophysically guided inversion (PGI): Linear example
======================================================

We do a comparison between the classic Tikhonov inversion
and our formulation of a petrophysically constrained inversion.
We explore it through the UBC linear example.

.. GENERATED FROM PYTHON SOURCE LINES 12-14

Tikhonov Inversion#
####################

.. GENERATED FROM PYTHON SOURCE LINES 14-90

.. code-block:: default


    import discretize as Mesh
    from SimPEG import (
        simulation,
        maps,
        data_misfit,
        directives,
        optimization,
        regularization,
        inverse_problem,
        inversion,
        utils,
    )
    import numpy as np
    import matplotlib.pyplot as plt

    # Random seed for reproductibility
    np.random.seed(1)
    # Mesh
    N = 100
    mesh = Mesh.TensorMesh([N])

    # Survey design parameters
    nk = 20
    jk = np.linspace(1.0, 60.0, nk)
    p = -0.25
    q = 0.25


    # Physics
    def g(k):
        return np.exp(p * jk[k] * mesh.cell_centers_x) * np.cos(
            np.pi * q * jk[k] * mesh.cell_centers_x
        )


    G = np.empty((nk, mesh.nC))

    for i in range(nk):
        G[i, :] = g(i)

    # True model
    mtrue = np.zeros(mesh.nC)
    mtrue[mesh.cell_centers_x > 0.2] = 1.0
    mtrue[mesh.cell_centers_x > 0.35] = 0.0
    t = (mesh.cell_centers_x - 0.65) / 0.25
    indx = np.abs(t) < 1
    mtrue[indx] = -(((1 - t ** 2.0) ** 2.0)[indx])

    mtrue = np.zeros(mesh.nC)
    mtrue[mesh.cell_centers_x > 0.3] = 1.0
    mtrue[mesh.cell_centers_x > 0.45] = -0.5
    mtrue[mesh.cell_centers_x > 0.6] = 0

    # SimPEG problem and survey
    prob = simulation.LinearSimulation(mesh, G=G, model_map=maps.IdentityMap())
    std = 0.01
    survey = prob.make_synthetic_data(mtrue, relative_error=std, add_noise=True)

    # Setup the inverse problem
    reg = regularization.Tikhonov(mesh, alpha_s=1.0, alpha_x=1.0)
    dmis = data_misfit.L2DataMisfit(data=survey, simulation=prob)
    opt = optimization.ProjectedGNCG(maxIter=10, maxIterCG=50, tolCG=1e-4)
    invProb = inverse_problem.BaseInvProblem(dmis, reg, opt)
    directiveslist = [
        directives.BetaEstimate_ByEig(beta0_ratio=1e-5),
        directives.BetaSchedule(coolingFactor=10.0, coolingRate=2),
        directives.TargetMisfit(),
    ]

    inv = inversion.BaseInversion(invProb, directiveList=directiveslist)
    m0 = np.zeros_like(mtrue)

    mnormal = inv.run(m0)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/vsts/work/1/s/SimPEG/simulation.py:546: UserWarning:

    G has not been implemented for the simulation

    SimPEG.InvProblem will set Regularization.mref to m0.

            SimPEG.InvProblem is setting bfgsH0 to the inverse of the eval2Deriv.
            ***Done using same Solver and solverOpts as the problem***
    /usr/share/miniconda/envs/deploy/lib/python3.7/site-packages/pymatsolver/direct.py:26: PardisoTypeConversionWarning:

    Converting csc_matrix matrix to CSR format, will slow down.

    model has any nan: 0
    =============================== Projected GNCG ===============================
      #     beta     phi_d     phi_m       f      |proj(x-g)-x|  LS    Comment   
    -----------------------------------------------------------------------------
    x0 has any nan: 0
       0  1.86e+01  1.00e+05  0.00e+00  1.00e+05    1.26e+06      0              
    /usr/share/miniconda/envs/deploy/lib/python3.7/site-packages/pymatsolver/direct.py:73: PardisoTypeConversionWarning:

    Converting csc_matrix matrix to CSR format, will slow down.

       1  1.86e+01  2.17e+01  2.28e+01  4.46e+02    5.68e-06      0              
    ------------------------- STOP! -------------------------
    0 : |fc-fOld| = 9.9554e+04 <= tolF*(1+|f0|) = 1.0000e+04
    0 : |xc-x_last| = 4.0057e+00 <= tolX*(1+|x0|) = 1.0000e-01
    1 : |proj(x-g)-x|    = 5.6842e-06 <= tolG          = 1.0000e-01
    1 : |proj(x-g)-x|    = 5.6842e-06 <= 1e3*eps       = 1.0000e-02
    0 : maxIter   =      10    <= iter          =      1
    ------------------------- DONE! -------------------------




.. GENERATED FROM PYTHON SOURCE LINES 91-93

Petrophysically constrained inversion #
########################################

.. GENERATED FROM PYTHON SOURCE LINES 93-168

.. code-block:: default


    # fit a Gaussian Mixture Model with n components
    # on the true model to simulate the laboratory
    # petrophysical measurements
    n = 3
    clf = utils.WeightedGaussianMixture(
        mesh=mesh,
        n_components=n,
        covariance_type="full",
        max_iter=100,
        n_init=3,
        reg_covar=5e-4,
    )
    clf.fit(mtrue.reshape(-1, 1))

    # Petrophyically constrained regularization
    reg = utils.make_PGI_regularization(
        gmmref=clf,
        mesh=mesh,
        alpha_s=1.0,
        alpha_x=1.0,
    )

    # Optimization
    opt = optimization.ProjectedGNCG(maxIter=10, maxIterCG=50, tolCG=1e-4)
    opt.remember("xc")

    # Setup new inverse problem
    invProb = inverse_problem.BaseInvProblem(dmis, reg, opt)

    # directives
    Alphas = directives.AlphasSmoothEstimate_ByEig(alpha0_ratio=10.0, verbose=True)
    beta = directives.BetaEstimate_ByEig(beta0_ratio=1e-6)
    betaIt = directives.PGI_BetaAlphaSchedule(
        verbose=True,
        coolingFactor=2.0,
        warmingFactor=1.0,
        tolerance=0.1,
        update_rate=1,
        progress=0.2,
    )
    targets = directives.MultiTargetMisfits(verbose=True)
    petrodir = directives.PGI_UpdateParameters()
    addmref = directives.PGI_AddMrefInSmooth(verbose=True)

    # Setup Inversion
    inv = inversion.BaseInversion(
        invProb, directiveList=[Alphas, beta, petrodir, targets, addmref, betaIt]
    )

    # Initial model same as for Tikhonov
    mcluster = inv.run(m0)

    # Final Plot
    fig, axes = plt.subplots(1, 3, figsize=(12 * 1.2, 4 * 1.2))
    for i in range(prob.G.shape[0]):
        axes[0].plot(prob.G[i, :])
    axes[0].set_title("Columns of matrix G")

    axes[1].hist(mtrue, bins=20, linewidth=3.0, density=True, color="k")
    axes[1].set_xlabel("Model value")
    axes[1].set_xlabel("Occurence")
    axes[1].hist(mnormal, bins=20, density=True, color="b")
    axes[1].hist(mcluster, bins=20, density=True, color="r")
    axes[1].legend(["Mtrue Hist.", "L2 Model Hist.", "PGI Model Hist."])

    axes[2].plot(mesh.cell_centers_x, mtrue, color="black", linewidth=3)
    axes[2].plot(mesh.cell_centers_x, mnormal, color="blue")
    axes[2].plot(mesh.cell_centers_x, mcluster, "r-")
    axes[2].plot(mesh.cell_centers_x, invProb.reg.objfcts[0].mref, "r--")

    axes[2].legend(("True Model", "L2 Model", "PGI Model", "Learned Mref"))
    axes[2].set_ylim([-2, 2])

    plt.show()



.. image-sg:: /content/examples/10-pgi/images/sphx_glr_plot_inv_0_PGI_Linear_1D_001.png
   :alt: Columns of matrix G
   :srcset: /content/examples/10-pgi/images/sphx_glr_plot_inv_0_PGI_Linear_1D_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    SimPEG.InvProblem will set Regularization.mref to m0.
    SimPEG.InvProblem will set Regularization.mref to m0.

            SimPEG.InvProblem is setting bfgsH0 to the inverse of the eval2Deriv.
            ***Done using same Solver and solverOpts as the problem***
    Alpha scales:  [1, 1]
    Alpha scales:  [1.0]
    Alpha scales:  [0.0, 0.5249361360067221, 0.0]
    model has any nan: 0
    =============================== Projected GNCG ===============================
      #     beta     phi_d     phi_m       f      |proj(x-g)-x|  LS    Comment   
    -----------------------------------------------------------------------------
    x0 has any nan: 0
       0  3.17e+00  1.00e+05  0.00e+00  1.00e+05    1.26e+06      0              
    geophys. misfits: 16.4 (target 10.0 [False]) | smallness misfit: 1486.4 (target: 50.0 [False])
    mref changed in  25  places
    Beta cooling evaluation: progress: [16.4] ; minimum progress targets: [80000.]
       1  3.17e+00  1.64e+01  2.72e+01  1.03e+02    2.59e+02      0              
    geophys. misfits: 7.6 (target 10.0 [True]) | smallness misfit: 820.8 (target: 50.0 [False])
    mref changed in  1  places
    Beta cooling evaluation: progress: [7.6] ; minimum progress targets: [13.2]
    Warming alpha_s to favor clustering:  1.3133362027424493
       2  3.17e+00  7.61e+00  2.60e+01  8.99e+01    4.05e+01      0   Skip BFGS  
    geophys. misfits: 7.5 (target 10.0 [True]) | smallness misfit: 664.0 (target: 50.0 [False])
    mref changed in  0  places
    Add mref to Smoothness. Changes in mref happened in 0.0 % of the cells
    Beta cooling evaluation: progress: [7.5] ; minimum progress targets: [11.]
    Warming alpha_s to favor clustering:  1.744840529522437
       3  3.17e+00  7.53e+00  4.50e+01  1.50e+02    3.91e+02      0              
    geophys. misfits: 8.2 (target 10.0 [True]) | smallness misfit: 55.8 (target: 50.0 [False])
    mref changed in  0  places
    Add mref to Smoothness. Changes in mref happened in 0.0 % of the cells
    Beta cooling evaluation: progress: [8.2] ; minimum progress targets: [11.]
    Warming alpha_s to favor clustering:  2.1172770544628325
       4  3.17e+00  8.24e+00  1.54e+00  1.31e+01    2.19e+03      0              
    geophys. misfits: 7.8 (target 10.0 [True]) | smallness misfit: 39.5 (target: 50.0 [True])
    All targets have been reached
    mref changed in  0  places
    Add mref to Smoothness. Changes in mref happened in 0.0 % of the cells
    Beta cooling evaluation: progress: [7.8] ; minimum progress targets: [11.]
    Warming alpha_s to favor clustering:  2.7069747985917143
    ------------------------- STOP! -------------------------
    1 : |fc-fOld| = 0.0000e+00 <= tolF*(1+|f0|) = 1.0000e+04
    0 : |xc-x_last| = 1.1469e-01 <= tolX*(1+|x0|) = 1.0000e-01
    0 : |proj(x-g)-x|    = 2.1896e+03 <= tolG          = 1.0000e-01
    0 : |proj(x-g)-x|    = 2.1896e+03 <= 1e3*eps       = 1.0000e-02
    0 : maxIter   =      10    <= iter          =      5
    ------------------------- DONE! -------------------------





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  5.923 seconds)

**Estimated memory usage:**  9 MB


.. _sphx_glr_download_content_examples_10-pgi_plot_inv_0_PGI_Linear_1D.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_inv_0_PGI_Linear_1D.py <plot_inv_0_PGI_Linear_1D.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_inv_0_PGI_Linear_1D.ipynb <plot_inv_0_PGI_Linear_1D.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
