
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "content/tutorials/07-fdem/plot_inv_1_em1dfm.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_content_tutorials_07-fdem_plot_inv_1_em1dfm.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_content_tutorials_07-fdem_plot_inv_1_em1dfm.py:


1D Inversion of for a Single Sounding
=====================================

Here we use the module *SimPEG.electromangetics.frequency_domain_1d* to invert
frequency domain data and recover a 1D electrical conductivity model.
In this tutorial, we focus on the following:

    - How to define sources and receivers from a survey file
    - How to define the survey
    - Sparse 1D inversion of with iteratively re-weighted least-squares

For this tutorial, we will invert 1D frequency domain data for a single sounding.
The end product is layered Earth model which explains the data. The survey
consisted of a vertical magnetic dipole source located 30 m above the
surface. The receiver measured the vertical component of the secondary field
at a 10 m offset from the source in ppm.

.. GENERATED FROM PYTHON SOURCE LINES 23-26

Import modules
--------------


.. GENERATED FROM PYTHON SOURCE LINES 26-55

.. code-block:: default


    import os, tarfile
    import numpy as np
    import matplotlib as mpl
    import matplotlib.pyplot as plt

    from discretize import TensorMesh

    import SimPEG.electromagnetics.frequency_domain as fdem
    from SimPEG.electromagnetics.utils.em1d_utils import (
        get_vertical_discretization_frequency,
    )
    from SimPEG.utils import mkvc, plot_1d_layer_model
    from SimPEG import (
        maps,
        data,
        data_misfit,
        inverse_problem,
        regularization,
        optimization,
        directives,
        inversion,
        utils,
    )

    plt.rcParams.update({"font.size": 16, "lines.linewidth": 2, "lines.markersize": 8})

    # sphinx_gallery_thumbnail_number = 2








.. GENERATED FROM PYTHON SOURCE LINES 56-64

Download Test Data File
-----------------------

Here we provide the file path to the data we plan on inverting.
The path to the data file is stored as a
tar-file on our google cloud bucket:
"https://storage.googleapis.com/simpeg/doc-assets/em1dfm.tar.gz"


.. GENERATED FROM PYTHON SOURCE LINES 64-83

.. code-block:: default


    # storage bucket where we have the data
    data_source = "https://storage.googleapis.com/simpeg/doc-assets/em1dfm.tar.gz"

    # download the data
    downloaded_data = utils.download(data_source, overwrite=True)

    # unzip the tarfile
    tar = tarfile.open(downloaded_data, "r")
    tar.extractall()
    tar.close()

    # path to the directory containing our data
    dir_path = downloaded_data.split(".")[0] + os.path.sep

    # files to work with
    data_filename = dir_path + "em1dfm_data.txt"






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Downloading https://storage.googleapis.com/simpeg/doc-assets/em1dfm.tar.gz
       saved to: /home/vsts/work/1/s/tutorials/07-fdem/em1dfm.tar.gz
    Download completed!




.. GENERATED FROM PYTHON SOURCE LINES 84-90

Load Data and Plot
------------------

Here we load and plot the 1D sounding data. In this case, we have the
secondary field response in ppm for a set of frequencies.


.. GENERATED FROM PYTHON SOURCE LINES 90-108

.. code-block:: default


    # Load field data
    # dobs = np.loadtxt(str(data_filename))
    dobs = np.loadtxt(str(data_filename), skiprows=1)

    # Define receiver locations and observed data
    frequencies = dobs[:, 0]
    dobs = mkvc(dobs[:, 1:].T)

    fig, ax = plt.subplots(1, 1, figsize=(7, 7))
    ax.loglog(frequencies, np.abs(dobs[0::2]), "k-o", lw=3)
    ax.loglog(frequencies, np.abs(dobs[1::2]), "k:o", lw=3)
    ax.set_xlabel("Frequency (Hz)")
    ax.set_ylabel("|Hs/Hp| (ppm)")
    ax.set_title("Magnetic Field as a Function of Frequency")
    ax.legend(["Real", "Imaginary"])





.. image-sg:: /content/tutorials/07-fdem/images/sphx_glr_plot_inv_1_em1dfm_001.png
   :alt: Magnetic Field as a Function of Frequency
   :srcset: /content/tutorials/07-fdem/images/sphx_glr_plot_inv_1_em1dfm_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.legend.Legend object at 0x7feed7a7c910>



.. GENERATED FROM PYTHON SOURCE LINES 109-117

Defining the Survey
-------------------

Here we demonstrate a general way to define the receivers, sources and survey.
The survey consisted of a vertical magnetic dipole source located 30 m above the
surface. The receiver measured the vertical component of the secondary field
at a 10 m offset from the source in ppm.


.. GENERATED FROM PYTHON SOURCE LINES 117-161

.. code-block:: default


    source_location = np.array([0.0, 0.0, 30.0])
    moment = 1.0

    receiver_location = np.array([10.0, 0.0, 30.0])
    receiver_orientation = "z"
    data_type = "ppm"

    # Receiver list
    receiver_list = []
    receiver_list.append(
        fdem.receivers.PointMagneticFieldSecondary(
            receiver_location,
            orientation=receiver_orientation,
            data_type=data_type,
            component="real",
        )
    )
    receiver_list.append(
        fdem.receivers.PointMagneticFieldSecondary(
            receiver_location,
            orientation=receiver_orientation,
            data_type=data_type,
            component="imag",
        )
    )

    # Define source list
    source_list = []
    for freq in frequencies:
        source_list.append(
            fdem.sources.MagDipole(
                receiver_list=receiver_list,
                frequency=freq,
                location=source_location,
                orientation="z",
                moment=moment,
            )
        )

    # Survey
    survey = fdem.survey.Survey(source_list)









.. GENERATED FROM PYTHON SOURCE LINES 162-168

Assign Uncertainties and Define the Data Object
-----------------------------------------------

Here is where we define the data that are inverted. The data are defined by
the survey, the observation values and the uncertainties.


.. GENERATED FROM PYTHON SOURCE LINES 168-176

.. code-block:: default


    # 5% of the absolute value
    uncertainties = 0.05 * np.abs(dobs) * np.ones(np.shape(dobs))

    # Define the data object
    data_object = data.Data(survey, dobs=dobs, noise_floor=uncertainties)









.. GENERATED FROM PYTHON SOURCE LINES 177-183

Defining a 1D Layered Earth (1D Tensor Mesh)
--------------------------------------------

Here, we define the layer thicknesses for our 1D simulation. To do this, we use
the TensorMesh class.


.. GENERATED FROM PYTHON SOURCE LINES 183-191

.. code-block:: default


    # Layer thicknesses
    inv_thicknesses = np.logspace(0, 1.5, 25)

    # Define a mesh for plotting and regularization.
    mesh = TensorMesh([(np.r_[inv_thicknesses, inv_thicknesses[-1]])], "0")









.. GENERATED FROM PYTHON SOURCE LINES 192-204

Define a Starting and/or Reference Model and the Mapping
--------------------------------------------------------

Here, we create starting and/or reference models for the inversion as
well as the mapping from the model space to the active cells. Starting and
reference models can be a constant background value or contain a-priori
structures. Here, the starting model is log(0.1) S/m.

Define log-conductivity values for each layer since our model is the
log-conductivity. Don't make the values 0!
Otherwise the gradient for the 1st iteration is zero and the inversion will
not converge.

.. GENERATED FROM PYTHON SOURCE LINES 204-212

.. code-block:: default


    # Define model. A resistivity (Ohm meters) or conductivity (S/m) for each layer.
    starting_model = np.log(0.1 * np.ones(mesh.nC))

    # Define mapping from model to active cells.
    model_mapping = maps.ExpMap()









.. GENERATED FROM PYTHON SOURCE LINES 213-216

Define the Physics using a Simulation Object
--------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 216-222

.. code-block:: default


    simulation = fdem.Simulation1DLayered(
        survey=survey, thicknesses=inv_thicknesses, sigmaMap=model_mapping
    )









.. GENERATED FROM PYTHON SOURCE LINES 223-233

Define Inverse Problem
----------------------

The inverse problem is defined by 3 things:

    1) Data Misfit: a measure of how well our recovered model explains the field data
    2) Regularization: constraints placed on the recovered model and a priori information
    3) Optimization: the numerical approach used to solve the inverse problem



.. GENERATED FROM PYTHON SOURCE LINES 233-257

.. code-block:: default


    # Define the data misfit. Here the data misfit is the L2 norm of the weighted
    # residual between the observed data and the data predicted for a given model.
    # The weighting is defined by the reciprocal of the uncertainties.
    dmis = data_misfit.L2DataMisfit(simulation=simulation, data=data_object)

    # Define the regularization (model objective function)
    reg_map = maps.IdentityMap(nP=mesh.nC)
    reg = regularization.Sparse(mesh, mapping=reg_map, alpha_s=0.025, alpha_x=1.0)

    # reference model
    reg.mref = starting_model

    # Define sparse and blocky norms p, q
    reg.norms = [0, 0]

    # Define how the optimization problem is solved. Here we will use an inexact
    # Gauss-Newton approach that employs the conjugate gradient solver.
    opt = optimization.ProjectedGNCG(maxIter=50, maxIterLS=20, maxIterCG=30, tolCG=1e-3)

    # Define the inverse problem
    inv_prob = inverse_problem.BaseInvProblem(dmis, reg, opt)









.. GENERATED FROM PYTHON SOURCE LINES 258-265

Define Inversion Directives
---------------------------

Here we define any directiveas that are carried out during the inversion. This
includes the cooling schedule for the trade-off parameter (beta), stopping
criteria for the inversion and saving inversion results at each iteration.


.. GENERATED FROM PYTHON SOURCE LINES 265-296

.. code-block:: default


    # Defining a starting value for the trade-off parameter (beta) between the data
    # misfit and the regularization.
    starting_beta = directives.BetaEstimate_ByEig(beta0_ratio=1e1)

    # Update the preconditionner
    update_Jacobi = directives.UpdatePreconditioner()

    # Options for outputting recovered models and predicted data for each beta.
    save_iteration = directives.SaveOutputEveryIteration(save_txt=False)

    # Directive for the IRLS
    update_IRLS = directives.Update_IRLS(
        max_irls_iterations=30, minGNiter=1, coolEpsFact=1.5, update_beta=True
    )

    # Updating the preconditionner if it is model dependent.
    update_jacobi = directives.UpdatePreconditioner()

    # Add sensitivity weights
    sensitivity_weights = directives.UpdateSensitivityWeights()

    # The directives are defined as a list.
    directives_list = [
        sensitivity_weights,
        starting_beta,
        save_iteration,
        update_IRLS,
        update_jacobi,
    ]








.. GENERATED FROM PYTHON SOURCE LINES 297-303

Running the Inversion
---------------------

To define the inversion object, we need to define the inversion problem and
the set of directives. We can then run the inversion.


.. GENERATED FROM PYTHON SOURCE LINES 303-311

.. code-block:: default


    # Here we combine the inverse problem and the set of directives
    inv = inversion.BaseInversion(inv_prob, directives_list)

    # Run the inversion
    recovered_model = inv.run(starting_model)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


                            SimPEG.InvProblem is setting bfgsH0 to the inverse of the eval2Deriv.
                            ***Done using same Solver, and solver_opts as the Simulation1DLayered problem***
                        
    model has any nan: 0
    =============================== Projected GNCG ===============================
      #     beta     phi_d     phi_m       f      |proj(x-g)-x|  LS    Comment   
    -----------------------------------------------------------------------------
    x0 has any nan: 0
       0  3.15e+02  1.40e+02  0.00e+00  1.40e+02    3.95e+01      0              
       1  1.58e+02  2.44e+01  1.13e-01  4.22e+01    1.76e+01      0              
       2  7.88e+01  7.94e+00  1.48e-01  1.96e+01    7.25e+00      0              
    Reached starting chifact with l2-norm regularization: Start IRLS steps...
    irls_threshold 2.42689865225539
       3  3.94e+01  3.46e+00  1.70e-01  1.02e+01    5.06e+00      0              
       4  9.79e+01  1.68e+00  1.54e-01  1.68e+01    6.33e+00      0              
       5  1.73e+02  3.25e+00  1.28e-01  2.54e+01    8.16e+00      0              
       6  1.41e+02  5.69e+00  1.00e-01  1.98e+01    3.06e+00      0              
       7  1.41e+02  5.03e+00  8.46e-02  1.70e+01    3.69e+00      0              
       8  1.41e+02  4.56e+00  7.25e-02  1.48e+01    3.79e+00      0              
       9  2.27e+02  4.08e+00  6.36e-02  1.85e+01    1.05e+01      0              
      10  2.27e+02  4.76e+00  5.57e-02  1.74e+01    5.42e+00      0              
      11  2.27e+02  4.50e+00  4.86e-02  1.56e+01    5.17e+00      0              
      12  3.61e+02  4.26e+00  4.07e-02  1.90e+01    1.34e+01      0   Skip BFGS  
      13  3.61e+02  4.95e+00  3.05e-02  1.60e+01    6.73e+00      0              
      14  3.61e+02  4.52e+00  2.22e-02  1.25e+01    7.08e+00      0              
      15  5.68e+02  4.36e+00  1.54e-02  1.31e+01    1.53e+01      0   Skip BFGS  
      16  5.68e+02  4.76e+00  1.02e-02  1.05e+01    8.06e+00      0              
      17  5.68e+02  4.64e+00  6.88e-03  8.54e+00    9.59e+00      0              
      18  8.86e+02  4.46e+00  4.58e-03  8.52e+00    1.64e+01      0              
      19  1.38e+03  4.49e+00  2.98e-03  8.59e+00    1.53e+01      0              
      20  1.38e+03  4.51e+00  1.97e-03  7.22e+00    6.19e+00      0   Skip BFGS  
      21  2.17e+03  4.36e+00  1.32e-03  7.23e+00    1.55e+01      0              
      22  3.43e+03  4.32e+00  8.82e-04  7.35e+00    1.54e+01      0   Skip BFGS  
      23  5.41e+03  4.32e+00  5.88e-04  7.50e+00    1.53e+01      0   Skip BFGS  
      24  8.53e+03  4.34e+00  3.91e-04  7.67e+00    1.52e+01      0              
      25  1.34e+04  4.36e+00  2.60e-04  7.85e+00    1.51e+01      0              
      26  2.11e+04  4.39e+00  1.73e-04  8.04e+00    1.50e+01      0              
      27  3.30e+04  4.42e+00  1.15e-04  8.22e+00    1.49e+01      0              
      28  5.15e+04  4.45e+00  7.67e-05  8.40e+00    1.48e+01      0              
      29  8.03e+04  4.48e+00  5.10e-05  8.57e+00    1.48e+01      0              
      30  8.03e+04  4.51e+00  3.40e-05  7.23e+00    5.95e+00      0              
      31  1.26e+05  4.36e+00  2.29e-05  7.25e+00    1.56e+01      0              
      32  1.99e+05  4.32e+00  1.53e-05  7.37e+00    1.53e+01      0   Skip BFGS  
    Reach maximum number of IRLS cycles: 30
    ------------------------- STOP! -------------------------
    1 : |fc-fOld| = 0.0000e+00 <= tolF*(1+|f0|) = 1.4148e+01
    1 : |xc-x_last| = 4.7725e-03 <= tolX*(1+|x0|) = 1.2741e+00
    0 : |proj(x-g)-x|    = 1.5289e+01 <= tolG          = 1.0000e-01
    0 : |proj(x-g)-x|    = 1.5289e+01 <= 1e3*eps       = 1.0000e-02
    0 : maxIter   =      50    <= iter          =     33
    ------------------------- DONE! -------------------------




.. GENERATED FROM PYTHON SOURCE LINES 312-315

Plotting Results
---------------------


.. GENERATED FROM PYTHON SOURCE LINES 315-372

.. code-block:: default


    # Load the true model and layer thicknesses
    true_model = np.array([0.1, 1.0, 0.1])
    true_layers = np.r_[20.0, 40.0, 160.0]

    # Extract Least-Squares model
    l2_model = inv_prob.l2model

    # Plot true model and recovered model
    fig = plt.figure(figsize=(8, 9))
    x_min = np.min(
        np.r_[model_mapping * recovered_model, model_mapping * l2_model, true_model]
    )
    x_max = np.max(
        np.r_[model_mapping * recovered_model, model_mapping * l2_model, true_model]
    )

    ax1 = fig.add_axes([0.2, 0.15, 0.7, 0.7])
    plot_1d_layer_model(true_layers, true_model, ax=ax1, show_layers=False, color="k")
    plot_1d_layer_model(
        mesh.h[0], model_mapping * l2_model, ax=ax1, show_layers=False, color="b"
    )
    plot_1d_layer_model(
        mesh.h[0], model_mapping * recovered_model, ax=ax1, show_layers=False, color="r"
    )
    ax1.set_xlim(0.01, 10)
    ax1.set_title("True and Recovered Models")
    ax1.legend(["True Model", "L2-Model", "Sparse Model"])
    plt.gca().invert_yaxis()

    # Plot predicted and observed data
    dpred_l2 = simulation.dpred(l2_model)
    dpred_final = simulation.dpred(recovered_model)

    fig = plt.figure(figsize=(11, 6))
    ax1 = fig.add_axes([0.2, 0.1, 0.6, 0.8])
    ax1.loglog(frequencies, np.abs(dobs[0::2]), "k-o")
    ax1.loglog(frequencies, np.abs(dobs[1::2]), "k:o")
    ax1.loglog(frequencies, np.abs(dpred_l2[0::2]), "b-o")
    ax1.loglog(frequencies, np.abs(dpred_l2[1::2]), "b:o")
    ax1.loglog(frequencies, np.abs(dpred_final[0::2]), "r-o")
    ax1.loglog(frequencies, np.abs(dpred_final[1::2]), "r:o")
    ax1.set_xlabel("Frequencies (Hz)")
    ax1.set_ylabel("|Hs/Hp| (ppm)")
    ax1.set_title("Predicted and Observed Data")
    ax1.legend(
        [
            "Observed (real)",
            "Observed (imag)",
            "L2-Model (real)",
            "L2-Model (imag)",
            "Sparse (real)",
            "Sparse (imag)",
        ],
        loc="upper left",
    )
    plt.show()



.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /content/tutorials/07-fdem/images/sphx_glr_plot_inv_1_em1dfm_002.png
         :alt: True and Recovered Models
         :srcset: /content/tutorials/07-fdem/images/sphx_glr_plot_inv_1_em1dfm_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /content/tutorials/07-fdem/images/sphx_glr_plot_inv_1_em1dfm_003.png
         :alt: Predicted and Observed Data
         :srcset: /content/tutorials/07-fdem/images/sphx_glr_plot_inv_1_em1dfm_003.png
         :class: sphx-glr-multi-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  19.153 seconds)

**Estimated memory usage:**  18 MB


.. _sphx_glr_download_content_tutorials_07-fdem_plot_inv_1_em1dfm.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_inv_1_em1dfm.py <plot_inv_1_em1dfm.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_inv_1_em1dfm.ipynb <plot_inv_1_em1dfm.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
